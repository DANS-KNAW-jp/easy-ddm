/**
 *
 */
package nl.knaw.dans.easy.web.download;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import nl.knaw.dans.easy.util.ZipDownloadParams;
import nl.knaw.dans.easy.web.bean.Services;

import org.apache.wicket.protocol.http.WebResponse;
import org.apache.wicket.util.resource.ResourceStreamNotFoundException;
import org.apache.wicket.util.time.Time;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class provides resource stream in the zip format.
 * The resource stream is retrieved by calling getInputStream().
 * Once a resource has been zipped, it will automatically closed it.
 *
 */
public class ZipDownload extends AbstractDownloadHandler
{
    private static final long         serialVersionUID             = -7250396009100112534L;
    private static final int          SELECTED_ITEM_MINIMUM_LENGTH = 1;
    private static final Logger       logger                       = LoggerFactory.getLogger(ZipDownload.class);
    
    private final FileDownloadResponse fileDownloadResponse;
    
    private String                    rootSid;
    private String                    zipName;
    private List<Map<String, String>> zipDataList;
    private File                      m_zipFile = null;
    private FileInputStream           fos = null;

    public static final String        DOWNLOAD_TYPE_ZIP            = "zip";
    
    public ZipDownload(FileDownloadResponse fileDownloadResponse)
    {
        this.fileDownloadResponse = fileDownloadResponse;
    }

//    public ZipDownload(JSONArray selectedItemList) throws DownlodException, JSONException
//    {
//        super(selectedItemList);
//    }


    protected void fetchParameters(JSONArray selectedItemList) throws JSONException, DownlodException
    {
        int numberOfSelectedItems = selectedItemList.length();
        if (selectedItemList == null || numberOfSelectedItems < SELECTED_ITEM_MINIMUM_LENGTH)
        {
            throw new DownlodException("Error - selectedItemList is null or contains less than 2 item.");
        }
        zipDataList = new ArrayList<Map<String, String>>();
        for (int i = 0; i < numberOfSelectedItems; i++)
        {
            Map<String, String> map = new HashMap<String, String>();
            JSONObject item = selectedItemList.getJSONObject(i);
            String itemNames[] = JSONObject.getNames(item);
            //TODO: LB20090805: what if the JSONObject contains garbage. Do we still need to copy that information?
            // and why would we copy from an untyped object to another untyped object if we have the luxury
            // of typing?
            for (int j = 0; j < itemNames.length; j++)
            {
                map.put(itemNames[j], item.getString(itemNames[j]));
            }
            zipDataList.add(map);
        }
    }

    protected File getZipFile()
    {
        if (m_zipFile != null)
            return m_zipFile;
        
        try
        {
            ZipDownloadParams zdp = new ZipDownloadParams(getZipName(), getRootSid());
            for (Map<String, String> item : zipDataList)
            {
                //TODO: LB20090805: Why not do this in fetchParamters and skip the whole copying from zipDataList to
                // zdp.item List process!
                zdp.addItem(item.get(ZipDownloadParams.PARAM_NAME_SID), item.get(ZipDownloadParams.PARAM_NAME_TYPE), item
                        .get(ZipDownloadParams.PARAM_NAME_PATH));

            }

            final File zipTempFile = File.createTempFile("easydownload_", "");
            m_zipFile = Services.getItemService().getZipFile(zdp, zipTempFile);
        }
        catch (Throwable e)
        {
            logger.error(e.getMessage(), e);
        }

        return m_zipFile;
    }
    
    public String getContentType()
    {
        return "application/zip";
    }
   
    public InputStream getInputStream() throws ResourceStreamNotFoundException
    {
        final File zipFile = getZipFile();
        if (zipFile == null)
            return null;
        
        try
        {
            // return zip file's inputstream and delete zip file after we've finished sending
            if (fos == null)
                fos = new FileInputStream(zipFile) {
                    @Override
                    public void close() throws IOException
                    {
                        super.close();
                        zipFile.delete();
                    }
                };
            return fos;
        } catch (FileNotFoundException e)
        {
            return null;
        }
    }

    public long length()
    {
        File zipFile = getZipFile();
        if (zipFile != null)
            return zipFile.length();
        else
            return -1;
    }

    public Time lastModifiedTime()
    {
        return Time.valueOf(new Date().getTime());
    }

    private String getRootSid()
    {
        return rootSid;
    }

    public void setRootSid(String rootSid)
    {
        this.rootSid = rootSid;
    }

    private String getZipName()
    {
        return zipName;
    }

    public void setZipName(String zipName)
    {
        this.zipName = zipName;
    }

    public void close() throws IOException
    {
        if (fos != null)
            fos.close();
    }

    @Override
    public void setHeaders(WebResponse response)
    {
        // TODO Auto-generated method stub
        
    }

}
